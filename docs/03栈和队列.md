# 第 3 章 栈和队列

[toc]

## 3.1 栈

- 栈的数学性质：n 个不同元素进栈，出栈元素不同排列的个数为 $\frac{1}{n+1}C ^n _{2n}$。上述公示称为_卡特兰（Catalan）_数
- 共享栈，是为了更有效的利用存储空间，两个栈的空间互相调节，只有在整个存储空间被占满时才会发生上溢。其存取数据的时间复杂度均为 O(1)，没有影响

顺序栈的默认操作

（1）声明一个栈并初始化：

`Elemtype stack[maxSize]; int top=-1;    //两句话连声明带初始化都有了`

（2）元素进栈：

`stack[++top]=x;    //仅一句话即实现进栈操作`

（3）元素 x 出栈：

`X=stack[top--];    //单目运算符在变量之前表示“先运算后使用”，之后则相反`

### 课后习题（错题本）

```
向一个栈顶指针为 top 的栈链（不带头结点）中插入一个 x 结点，则执行
	x->next=top; top=x
```

## 3.2 队列

- 对头（**Front**）。允许删除的一端，又称队首。
- 队尾（**Rear**）。允许插入的一端。
- 空队列。不含任何元素的空表。

### 队列的顺序存储结构

1. **队列的顺序存储**

队头指针 front 指向队头元素，队尾指针 rear 指向队尾元素的**下一个位置**（不同教材的定义可能不同，默认当前定义）

​	队列的顺序存储结构可描述为

```c
#define MaxSize 50  //定义队列中元素的最大个数
#define ElemType int
typedef struct{
    ElemType data[MaxSize]; //存放队列元素
    int front,rear; //对头指针和队尾指针
}SqQueue;
```

​	初始状态（队空条件）：Q.front == Q.rear == 0。
​	进队操作：队不满时，先送值到队尾元素，再将队尾指针加 1。
​	出队操作：队不空时，先取队头元素值，再将队头指针加 1。

2. **循环队列**

牺牲一个单元来区分队空和队满，约定以“队头指针在队尾指针的下一位置作为队满的标志”。

​	队满条件： (Q.rear+1) % MaxSize == Q.front。

​	队空条件仍：Q.front == Q.rear。

​	队列中元素的个数：(Q.rear-Q.front+MaxSize)% MaxSize。

### 双端队列

**输出受限的双端队列**：允许在一端进行插入和删除，但在另一端只允许插入的双端队列称为_输出受限的双端队列_。

**输入受限的双端队列**：允许在一端进行插入和删除，但在另一端只允许删除的双端队列称为_输入受限的双端队列_。

​	**例** 设有一个双端队列，输入序列为 1，2，3，4，试分别求出以下条件的输出序列。

​	（1）能由输入受限的双端队列得到，但不能由输出受限的双端队列得到的输出序列。

​	（2）能由输出受限的双端队列得到，但不能由输入受限的双端队列得到的输出序列。

​	（3）既不能由输入受限的双端队列得到，又不能由输出受限的双端队列得到的输出序列。

> 答案：（1）4，1，3，2 ；（2）4，2，1，3 ；（3）4，2，3，1 。一般考试不考这么难，只要验证答案即可。

#### 课后习题（错题本）

1. 已知循环队列存储在一维数组 A[0...n-1] 中，且队列非空时 front 和 rear 分别指向队头元素和队尾元素。若初始时队列为空，且要求第一个进入队列的元素存储在 A[0] 处，则初始时 front 和 rear 的值分别是（   ， ）。

> 0,n-1    重点是 rear 指向的是队尾元素而不是队尾元素的下一个，调用入队方法时要注意

2. 最适合用作链队的链表是：**带队首指针和队尾指针的非循环单链表**。

> 队列需要在双端进行操作，循环链表是画蛇添足

3. 用链式存储方式的队列进行删除操作时需要 **头尾指针可能都要修改**。

> 通常只需要修改头指针，当仅有一个元素时，删除后队列为空，需修改尾指针为 rear=front。

## 3.3 栈和队列的应用

#### 栈在表达式求值中的应用

中缀表达式转换为前缀或后缀表达式的手工做法

步骤 1: 按照运算符的优先级对所有的运算单位加括号。

式子变成`((a/b)+(((c*d)-(e*f))/g))`。

步骤 2: 转化为前缀或后缀表达式。

前缀：把运算符号移动到对应的括号前面，式子变成`+(/(ab)/(-(*(cd)*(ef))g))`。

把括号去掉：`+/ab/-*cd*efg`。

后缀：把运算符号移动到对应的括号后面，式子变成`((ab)/(((cd)*(ef)*)-g)/)+`。

把括号去掉：`ab/cd*ef*-g/+`。

#### 利用栈将带括号的四则运算转换为等价的后缀表达式

后面用代码实现一下。第 90 页 11 题

## 3.4 特殊矩阵的压缩存储

 用一维数组 A[0...n-1] 为例，其存储结构关系式为

$LOC(a_i)=LOC(a_o)+i\times L (0 \le i <n)$

### 3.4.3 矩阵的压缩存储

#### 1. 对称矩阵

- i<j 上三角区
- i=j 主对角线
- i>j 下三角区

映射需要根据题目计算，不需要记忆

#### 2. 三角矩阵

特点：上三角区全为常量（下三角矩阵）；或下三角区全为常量（上三角矩阵）

压缩：按行优先/列优先规则依次存储非常量区域，并在最后一个位置存放常量 c （第 n(n+1)/2）

#### 3. 三对角矩阵

（带状矩阵）

特点：当$\lvert i-j\rvert>1$时，有$a_{i,j}=0 (1\le i,j\le n)$。

压缩：按行优先/列优先规则依次存储带状区域

计算：在一维数组 B_（下标从 0 开始）_中存放的下标为$k=2i+j-3$,

####  4. 稀疏矩阵

1. 将非零元素及其相应的行和列构成一个三元组（行标，列标，值），稀疏矩阵压缩存储后便失去了随机存取的特性。
2. 十字链表法

![十字链表法](https://huxzhi-imgsubmit.oss-cn-beijing.aliyuncs.com/img/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E6%B3%95.png)
